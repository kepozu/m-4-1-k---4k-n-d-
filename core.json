{
  "constants": {
    "WHOLE_NOTE_BEAT_COUNT": 4,
    "MAX_COMPENSATION_NUMERATOR": 32,
    "EXCLUDED_COMPENSATION_NUMERATOR": 4,
    "FALLBACK_ABSORPTION_RATES": {
      "1": 3,
      "2": 2,
      "3": 1
    }
  },
  "calculator": {
    "_calculate_primary_compensation": "def _calculate_primary_compensation(cls, ideal_beat_compensation, explanation):\n    explanation.extend([\n        (\n            '\\nResult: Using ideal compensation value '\n            f'm = {ideal_beat_compensation} (since m > 0).'\n        ),\n        'This beat count will be divided into an efficient combination of measures.',\n        (\n            'Available time signatures: 1/4 to '\n            f'{MusicalConstants.MAX_COMPENSATION_NUMERATOR}/4 '\n            f'(excluding {MusicalConstants.EXCLUDED_COMPENSATION_NUMERATOR}/4)'\n        ),\n    ])\n\n    available_numerators = [\n        n for n in range(MusicalConstants.MAX_COMPENSATION_NUMERATOR, 0, -1)\n        if n != MusicalConstants.EXCLUDED_COMPENSATION_NUMERATOR\n    ]\n\n    remaining_beats = int(ideal_beat_compensation)\n    compensation_measures = {}\n    explanation.append('\\nDivision Calculation:')\n\n    for num in available_numerators:\n        if remaining_beats >= num:\n            count = remaining_beats // num\n            compensation_measures[f'{num}/4'] = count\n            remaining_beats %= num\n            explanation.append(\n                f'  Using {count} measure(s) of {num}/4 '\n                f'(Remaining: {remaining_beats} beats)'\n            )\n        if remaining_beats == 0:\n            break\n\n    return compensation_measures, explanation",
    "_calculate_fallback_compensation": "def _calculate_fallback_compensation(cls, total_beats, total_measures, explanation):\n    explanation.extend([\n        (\n            '\\nFallback Goal: Insert additional measures to align the '\n            'entire timeline to a \"Total Beats = 4 * Total Measures\" structure.'\n        )\n    ])\n\n    excess_beats = total_beats - (\n        MusicalConstants.WHOLE_NOTE_BEAT_COUNT * total_measures\n    )\n    explanation.extend([\n        '\\nExcess Beat Calculation (based on 4/4 time):',\n        (\n            f'  Excess Beats = S - 4*Σkᵢ = {total_beats} - '\n            f'4*{total_measures} = {excess_beats}'\n        ),\n    ])\n\n    if excess_beats <= 0:\n        message = (\n            '\\nNo additional measures are needed as there are no excess beats.'\n            if excess_beats == 0 else\n            '\\nWarning: Timeline is deficient but does not meet primary goal conditions.'\n        )\n        explanation.append(message)\n        return {}, explanation\n\n    explanation.extend([\n        'This excess will be absorbed by the fewest possible additional measures.',\n        'Priority is given to signatures that absorb more beats (i.e., have a larger difference from 4/4 time).',\n    ])\n    # Note: JSON keys are strings, so we must convert back to int for sorting.\n    for num_str, absorb in MusicalConstants.FALLBACK_ABSORPTION_RATES.items():\n        num = int(num_str)\n        explanation.append(\n            f'  - Adding one {num}/4 measure absorbs {absorb} beats (4-{num}={absorb}).'\n        )\n\n    remainder = int(excess_beats)\n    suggestion = {}\n    explanation.append('\\nSuggestion Calculation:')\n\n    # Convert string keys from JSON to int for proper sorting.\n    sorted_rates = sorted(\n        [(int(k), v) for k, v in MusicalConstants.FALLBACK_ABSORPTION_RATES.items()],\n        key=lambda item: item[1],\n        reverse=True,\n    )\n\n    for num, absorb_rate in sorted_rates:\n        if remainder >= absorb_rate:\n            count = remainder // absorb_rate\n            suggestion[f'{num}/4'] = count\n            remainder %= absorb_rate\n            explanation.append(\n                f'  Number of {num}/4 measures (absorbs {absorb_rate} beats): {count}'\n            )\n\n    s_add = sum(Fraction(int(k.split('/')[0])) * v for k, v in suggestion.items())\n    k_add = sum(suggestion.values())\n    s_new = total_beats + s_add\n    k_new = total_measures + k_add\n    target_beats = MusicalConstants.WHOLE_NOTE_BEAT_COUNT * k_new\n\n    explanation.extend([\n        '\\nVerification:',\n        f'  Suggested additional measures: {suggestion}',\n        f'  Added Beats S_add = {s_add}, Added Measures k_add = {k_add}',\n        f'  New Total Beats S_new = {s_new}, New Total Measures k_new = {k_new}',\n        f'  Target Beats = 4 * k_new = {target_beats}',\n        '  S_new matches 4 * k_new, aligning the timeline.'\n        if s_new == target_beats else '  Verification mismatch - check the logic.',\n    ])\n\n    return suggestion, explanation",
    "calculate": "def calculate(cls, added_groups):\n    if not added_groups:\n        return CalculationResult(\n            measures={},\n            user_denominator=4,\n            explanation=['Error: No groups have been added.'],\n            fallback_used=False,\n        )\n\n    for i, group in enumerate(added_groups):\n        if not all(\n            isinstance(val, int) and val > 0\n            for val in [group.numerator, group.denominator, group.count]\n        ):\n            raise ValueError(f'Group {i} contains non-positive integers.')\n        if group.denominator == 0:\n            raise ValueError('Invalid group data: denominator cannot be zero.')\n\n    total_beats = sum(\n        Fraction(g.numerator * MusicalConstants.WHOLE_NOTE_BEAT_COUNT * g.count, g.denominator)\n        for g in added_groups\n    )\n    total_measures = sum(g.count for g in added_groups)\n\n    denominators = [g.denominator for g in added_groups]\n    user_denominator = max(set(denominators), key=denominators.count)\n\n    explanation = ['Calculation Steps:', '--------------------', 'Added Groups:']\n    for i, group in enumerate(added_groups):\n        group_beats = Fraction(\n            group.numerator * MusicalConstants.WHOLE_NOTE_BEAT_COUNT * group.count,\n            group.denominator,\n        )\n        explanation.append(\n            f'  Group {i+1}: {group.numerator}/{group.denominator} x '\n            f'{group.count} measures -> {group_beats} beats'\n        )\n    explanation.extend([\n        '--------------------',\n        f'Total Inserted Measures (Σkᵢ) = {total_measures}',\n        f'Total Inserted Beats (S) = {total_beats}',\n        '--------------------',\n    ])\n\n    if total_beats.denominator != 1:\n        explanation.append(\n            '\\nWarning: Total beats is not a whole number. Calculations may be imprecise.'\n        )\n\n    if total_beats == MusicalConstants.WHOLE_NOTE_BEAT_COUNT * total_measures:\n        explanation.extend([\n            '\\nStructural Analysis:',\n            f'  Total Beats ({total_beats}) is exactly 4 times Total Measures ({total_measures}).',\n            '  The timeline is already perfectly balanced.',\n            '\\nResult: No compensation is required.',\n        ])\n        return CalculationResult(\n            measures={},\n            user_denominator=user_denominator,\n            explanation=explanation,\n            fallback_used=False,\n        )\n\n    ideal_beat_compensation = (\n        MusicalConstants.WHOLE_NOTE_BEAT_COUNT * (total_measures + 1) - total_beats\n    )\n    explanation.extend([\n        'Primary Goal: Align total beats to 4 * (Total Measures + 1)',\n        'Ideal Compensation Beats (m) Formula:',\n        '  m = 4 * (1 + Σkᵢ) - S',\n        f'  m = 4 * (1 + {total_measures}) - {total_beats} = {ideal_beat_compensation}',\n    ])\n\n    if ideal_beat_compensation > 0 and ideal_beat_compensation.denominator == 1:\n        result, explanation = cls._calculate_primary_compensation(\n            ideal_beat_compensation, explanation\n        )\n        return CalculationResult(\n            measures=result,\n            user_denominator=user_denominator,\n            explanation=explanation,\n            fallback_used=False,\n        )\n    else:\n        explanation.append(\n            f'\\nResult: Ideal value m ({ideal_beat_compensation}) is not a positive integer, using fallback logic.'\n        )\n        result, explanation = cls._calculate_fallback_compensation(\n            total_beats, total_measures, explanation\n        )\n        return CalculationResult(\n            measures=result,\n            user_denominator=user_denominator,\n            explanation=explanation,\n            fallback_used=True,\n        )"
  },
  "verifier": {
    "_lcm": "def _lcm(a, b):\n    return abs(a * b) // math.gcd(a, b) if a != 0 and b != 0 else 0",
    "verify_beat_conservation": "def verify_beat_conservation(added_groups, compensation_result, fallback_used):\n    explanation = ['=== Beat Conservation Verification ===']\n    try:\n        total_added_beats = sum(\n            Fraction(g.numerator * MusicalConstants.WHOLE_NOTE_BEAT_COUNT * g.count, g.denominator)\n            for g in added_groups\n        )\n        total_added_measures = sum(g.count for g in added_groups)\n    except (AttributeError, ZeroDivisionError, TypeError) as e:\n        explanation.append(f'FAIL: Invalid added_groups data: {e}')\n        return False, explanation\n\n    explanation.append(f'Added groups total beats: {total_added_beats}')\n    explanation.append(f'Added groups total measures: {total_added_measures}')\n\n    compensation_beats = Fraction(0)\n    compensation_measures = 0\n    try:\n        for measure_str, count in compensation_result.items():\n            num, den = map(int, measure_str.split('/'))\n            compensation_beats += Fraction(\n                num * MusicalConstants.WHOLE_NOTE_BEAT_COUNT * count, den\n            )\n            compensation_measures += count\n    except (ValueError, ZeroDivisionError) as e:\n        explanation.append(f'FAIL: Invalid compensation_result data: {e}')\n        return False, explanation\n\n    explanation.append(f'Compensation beats: {compensation_beats}')\n    explanation.append(f'Compensation measures: {compensation_measures}')\n\n    total_beats = total_added_beats + compensation_beats\n    total_measures = total_added_measures + compensation_measures\n\n    if fallback_used:\n        target_beats = MusicalConstants.WHOLE_NOTE_BEAT_COUNT * total_measures\n        explanation.append(f'Fallback target: 4 * {total_measures} = {target_beats}')\n    elif not compensation_result:\n        target_beats = total_added_beats\n        explanation.append(\n            f'Primary target (no compensation needed): Timeline is self-balanced at {target_beats} beats.'\n        )\n    else:\n        target_beats = MusicalConstants.WHOLE_NOTE_BEAT_COUNT * (total_added_measures + 1)\n        explanation.append(\n            f'Primary target: 4 * ({total_added_measures} + 1) = {target_beats}'\n        )\n\n    is_valid = total_beats == target_beats\n    explanation.append(f'Actual total beats: {total_beats}')\n    explanation.append(f'Target beats: {target_beats}')\n    explanation.append(f\"Conservation check: {'PASS' if is_valid else 'FAIL'}\")\n    return is_valid, explanation",
    "verify_mathematical_constraints": "def verify_mathematical_constraints(added_groups, compensation_result, fallback_used):\n    explanation = ['=== Mathematical Constraints Verification ===']\n    is_valid = True\n\n    for i, group in enumerate(added_groups):\n        if not all(val > 0 for val in [group.numerator, group.denominator, group.count]):\n            explanation.append(f'FAIL: Group {i+1} has non-positive values.')\n            is_valid = False\n        if (group.denominator & (group.denominator - 1)) != 0:\n            explanation.append(\n                f'WARNING: Group {i+1} denominator {group.denominator} is not a power of 2.'\n            )\n\n    for measure_str, count in compensation_result.items():\n        if count <= 0:\n            explanation.append(f'FAIL: Compensation measure {measure_str} has non-positive count.')\n            is_valid = False\n            continue\n        try:\n            num, den = map(int, measure_str.split('/'))\n            if num <= 0 or den <= 0:\n                explanation.append(f'FAIL: Compensation measure {measure_str} has invalid signature.')\n                is_valid = False\n            if (den & (den - 1)) != 0:\n                explanation.append(f'WARNING: Compensation denominator {den} is not a power of 2.')\n        except ValueError:\n            explanation.append(f'FAIL: Invalid measure format: {measure_str}.')\n            is_valid = False\n\n    total_beats_fraction = sum(\n        Fraction(g.numerator * MusicalConstants.WHOLE_NOTE_BEAT_COUNT * g.count, g.denominator)\n        for g in added_groups\n    )\n    for measure_str, count in compensation_result.items():\n        num, den = map(int, measure_str.split('/'))\n        total_beats_fraction += Fraction(\n            num * MusicalConstants.WHOLE_NOTE_BEAT_COUNT * count, den\n        )\n\n    explanation.append(f'Precise total beats (fraction): {total_beats_fraction}')\n    if total_beats_fraction.denominator != 1:\n        explanation.append('FAIL: Total beats is not an integer, indicating a calculation error.')\n        is_valid = False\n    else:\n        explanation.append('PASS: Total beats is an integer.')\n\n    explanation.append(f\"Constraint check: {'PASS' if is_valid else 'FAIL'}\")\n    return is_valid, explanation",
    "verify_alternative_calculation": "def verify_alternative_calculation(cls, added_groups, compensation_result, fallback_used):\n    explanation = ['=== Alternative Calculation Verification ===']\n\n    all_denominators = [g.denominator for g in added_groups]\n    for measure_str in compensation_result:\n        _, den = map(int, measure_str.split('/'))\n        all_denominators.append(den)\n\n    if not all_denominators:\n        explanation.append('No denominators found for LCM calculation.')\n        return True, explanation\n\n    common_denominator = 1\n    for den in all_denominators:\n        common_denominator = cls._lcm(common_denominator, den)\n    explanation.append(f'Common denominator for precise calculation: {common_denominator}')\n\n    total_beats_precise = 0\n    total_added_measures = 0\n    total_compensation_measures = 0\n    for group in added_groups:\n        total_beats_precise += (\n            group.numerator * (common_denominator // group.denominator) * group.count\n        )\n        total_added_measures += group.count\n    for measure_str, count in compensation_result.items():\n        num, den = map(int, measure_str.split('/'))\n        total_beats_precise += num * (common_denominator // den) * count\n        total_compensation_measures += count\n\n    total_beats_quarter = (\n        total_beats_precise * MusicalConstants.WHOLE_NOTE_BEAT_COUNT\n    ) // common_denominator\n\n    explanation.append(f'Total beats (quarter notes) via LCM: {total_beats_quarter}')\n\n    if fallback_used:\n        total_measures = total_added_measures + total_compensation_measures\n        expected_beats = MusicalConstants.WHOLE_NOTE_BEAT_COUNT * total_measures\n    elif not compensation_result:\n        expected_beats = MusicalConstants.WHOLE_NOTE_BEAT_COUNT * total_added_measures\n    else:\n        expected_beats = MusicalConstants.WHOLE_NOTE_BEAT_COUNT * (total_added_measures + 1)\n    explanation.append(f'Expected beats: {expected_beats}')\n\n    is_valid = total_beats_quarter == expected_beats\n    explanation.append(f\"Alternative calculation: {'PASS' if is_valid else 'FAIL'}\")\n    return is_valid, explanation",
    "verify_structural_integrity": "def verify_structural_integrity(added_groups, compensation_result, fallback_used):\n    explanation = ['=== Structural Integrity Verification ===']\n    is_valid = True\n\n    total_beats = sum(\n        Fraction(g.numerator * MusicalConstants.WHOLE_NOTE_BEAT_COUNT * g.count, g.denominator)\n        for g in added_groups\n    )\n    total_measures = sum(g.count for g in added_groups)\n    ideal_m = (\n        MusicalConstants.WHOLE_NOTE_BEAT_COUNT * (total_measures + 1) - total_beats\n    )\n\n    explanation.append(f'Calculated ideal_m: {ideal_m}')\n    explanation.append(f'Fallback used: {fallback_used}')\n\n    is_self_balanced = (\n        total_beats == MusicalConstants.WHOLE_NOTE_BEAT_COUNT * total_measures\n    )\n\n    if not compensation_result and not fallback_used:\n        if is_self_balanced:\n            explanation.append('PASS: Correctly identified self-balanced timeline.')\n        else:\n            explanation.append('FAIL: No compensation returned for an unbalanced timeline.')\n            is_valid = False\n    elif fallback_used:\n        if ideal_m > 0 and ideal_m.denominator == 1:\n            explanation.append('FAIL: Fallback used when ideal_m > 0.')\n            is_valid = False\n        else:\n            explanation.append('PASS: Correctly selected fallback logic.')\n    else:\n        if ideal_m <= 0 or ideal_m.denominator != 1:\n            explanation.append('FAIL: Primary logic used when ideal_m is not a positive integer.')\n            is_valid = False\n        elif is_self_balanced:\n            explanation.append('FAIL: Primary logic used on a self-balanced timeline.')\n            is_valid = False\n        else:\n            explanation.append('PASS: Correctly selected primary compensation logic.')\n\n    if fallback_used:\n        # JSON keys are strings, so we must create the set from string keys.\n        allowed_fallback = {f'{n}/4' for n in MusicalConstants.FALLBACK_ABSORPTION_RATES.keys()}\n        invalid_measures = set(compensation_result.keys()) - allowed_fallback\n        if invalid_measures:\n            explanation.append(f'FAIL: Invalid fallback measures found: {invalid_measures}.')\n            is_valid = False\n\n    explanation.append(f\"Structural integrity: {'PASS' if is_valid else 'FAIL'}\")\n    return is_valid, explanation"
  }
}
